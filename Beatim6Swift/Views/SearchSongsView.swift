//
//  SearchSongsView.swift
//  MusicKit_Demo
//
//  Created by Shunzhe on 2022/01/22.
//

import SwiftUI
import MusicKit

struct SearchSongsView: View {
    
    enum SearchCategory: String, CaseIterable {
        case artist = "Artist"
        case song = "Song"
    }
    
    @State private var searchTerm: String = ""
    @State private var selectedCategory: SearchCategory = .artist
    @State private var searchResultSongs: MusicItemCollection<Song> = []
    @State private var searchResultArtists: MusicItemCollection<Artist> = []
    @State private var uniqueArtists: MusicItemCollection<Artist> = []
    @State private var fetchedTopSongs: [FetchedSong] = []
    @State private var isPerformingSearch: Bool = false
    @State private var musicSubscription: MusicSubscription?
    @State private var showDeleteAlert = false
    @Binding var currentArtistName: String?
    @Binding var musicDefaultBpm: Double
    @Binding var bpmErrorMessage: String
    @Binding var tempoRatioEvaluationEnabled: Bool
    @Binding var autoPause: Bool
    @EnvironmentObject var stepSoundManager: StepSoundManager
    @EnvironmentObject var spmManager: SPMManager
    @EnvironmentObject var songHistoryManager: SongHistoryManager
    @EnvironmentObject var authManager: AuthManager

    @FocusState private var isSearchFieldFocused: Bool // üéØ „Éï„Ç©„Éº„Ç´„ÇπÁä∂ÊÖã„ÇíÁÆ°ÁêÜ
    @State private var showCancelButton: Bool = false
    
    init(musicDefaultBpm: Binding<Double>, currentArtistName: Binding<String?>, bpmErrorMessage: Binding<String>, tempoRatioEvaluationEnabled: Binding<Bool>, autoPause: Binding<Bool>){
        self._musicDefaultBpm = musicDefaultBpm
        self._currentArtistName = currentArtistName
        self._bpmErrorMessage = bpmErrorMessage
        self._tempoRatioEvaluationEnabled = tempoRatioEvaluationEnabled
        self._autoPause = autoPause
    }
    
    var body: some View {
        VStack {
            // üîç Ê§úÁ¥¢„Éê„Éº
            HStack {
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.gray)
                    TextField(
                        selectedCategory == .artist ? "„Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÂêç„ÇíÊ§úÁ¥¢" :
                            selectedCategory == .song ? "Êõ≤Âêç„ÇíÊ§úÁ¥¢" : "Search",
                        text: $searchTerm,
                        onEditingChanged: { isEditing in
                        showCancelButton = true
                    }, onCommit: {
                        performSearch()
                    })
                    .focused($isSearchFieldFocused)
                    .foregroundColor(.primary)
                    .submitLabel(.search)
                    
                    if !searchTerm.isEmpty {
                        Button(action: {
                            searchTerm = ""
                            searchResultSongs = []
                            searchResultArtists = []
                            fetchedTopSongs = []
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(.gray)
                        }
                    }
                }
                .padding(8)
                .background(Color(.systemGray6))
                .cornerRadius(10)
                
                if showCancelButton {
                    Button("Cancel") {
                        searchTerm = ""
                        isSearchFieldFocused = false
                        
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
                            showCancelButton = false // „Éï„Ç©„Éº„Ç´„ÇπËß£Èô§Âæå„Å´„Éú„Çø„É≥„ÇíÈùûË°®Á§∫„Å´„Åô„Çã
                            searchResultSongs = []
                            searchResultArtists = []
                            fetchedTopSongs = []
                        }
                    }
                    .foregroundColor(.red)
                }
            }
            .padding(.horizontal)
            .padding(.top, 8)
            
            Picker("Search Type", selection: $selectedCategory) {
                ForEach(SearchCategory.allCases, id: \..self) { category in
                    Text(category.rawValue)
                }
            }
            .pickerStyle(SegmentedPickerStyle())
            .padding(.horizontal)
            
            // üîÑ Ê§úÁ¥¢‰∏≠„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº
            if isPerformingSearch {
                ProgressView()
                    .padding()
            }
            
            
            // üéµ Ê§úÁ¥¢ÁµêÊûú„É™„Çπ„Éà
            if selectedCategory == .song && !searchResultSongs.isEmpty {
                List {
                    Section(header: Text("Search Results")) {
                        ForEach(searchResultSongs) { song in
                            SongInfoView(
                                songItem: song,
                                currentArtistName: $currentArtistName,
                                musicDefaultBpm: $musicDefaultBpm,
                                bpmErrorMessage: $bpmErrorMessage,
                                autoPause: $autoPause
                            )
                                .environmentObject(songHistoryManager)
                                .environmentObject(spmManager)
                                .environmentObject(authManager)
                        }
                    }
                    Section(footer: SpacerView()) {}
                }
                .listStyle(PlainListStyle())
            } else if selectedCategory == .artist && !searchResultArtists.isEmpty {
                List {
                    ForEach(searchResultArtists, id: \.id) { artist in
                        NavigationLink(
                            destination: ArtistTopSongsView(
                                artist: artist,
                                currentArtistName: $currentArtistName,
                                musicDefaultBpm: $musicDefaultBpm,
                                bpmErrorMessage: $bpmErrorMessage,
                                tempoRatioEvaluationEnabled: $tempoRatioEvaluationEnabled,
                                autoPause: $autoPause
                            )
                            .environmentObject(spmManager)
                            .environmentObject(songHistoryManager)
                            .environmentObject(authManager)
                        ) {
                            HStack {
                                AsyncImage(url: artist.artwork?.url(width: 40, height: 40)) { image in
                                    image.resizable()
                                } placeholder: {
                                    Color.gray
                                }
                                .frame(width: 40, height: 40)
                                .clipShape(Circle())

                                Text(artist.name)
                                    .font(.headline)
                                    .padding(.leading, 8)
                            }
                        }
                    }
                    Section(footer: SpacerView()) {}
                }
                .listStyle(PlainListStyle())
            } else if selectedCategory == .artist && !uniqueArtists.isEmpty {
                List {
                    Section(header: Text("‰∫∫Ê∞ó„ÅÆ„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà")) {
                        ForEach(uniqueArtists, id: \.id) { artist in
                            NavigationLink(
                                destination: ArtistTopSongsView(
                                    artist: artist,
                                    currentArtistName: $currentArtistName,
                                    musicDefaultBpm: $musicDefaultBpm,
                                    bpmErrorMessage: $bpmErrorMessage,
                                    tempoRatioEvaluationEnabled: $tempoRatioEvaluationEnabled,
                                    autoPause: $autoPause
                                )
                                .environmentObject(spmManager)
                                .environmentObject(songHistoryManager)
                                .environmentObject(authManager)
                            ) {
                                HStack {
                                    AsyncImage(url: artist.artwork?.url(width: 40, height: 40)) { image in
                                        image.resizable()
                                    } placeholder: {
                                        Color.gray
                                    }
                                    .frame(width: 40, height: 40)
                                    .clipShape(Circle())

                                    Text(artist.name)
                                        .font(.headline)
                                        .padding(.leading, 8)
                                }
                            }
                        }
                    }
                    Section(footer: SpacerView()) {}
                }
                .listStyle(PlainListStyle())
            } else {
                List {
                    Section(
                        header: HStack {
                            Text("ÂÜçÁîü„Åï„Çå„ÅüÊõ≤")
                            Spacer()
                            Button(action: {
                                showDeleteAlert = true // ‚úÖ „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
                            }) {
                                Text("delete all")
                                    .foregroundColor(.red)
                                    .font(.subheadline)
                            }
                            .alert(isPresented: $showDeleteAlert) { // ‚úÖ ÂâäÈô§Á¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
                                Alert(
                                    title: Text("Clear History"),
                                    message: Text("Do you really want to delete all history?"),
                                    primaryButton: .destructive(Text("delete")) {
                                        songHistoryManager.clearHistory() // ‚úÖ Â±•Ê≠¥ÂâäÈô§
                                    },
                                    secondaryButton: .cancel()
                                )
                            }
                        }
                    ) {
                        let sortedSongs = songHistoryManager.playedSongs.sorted {
                            evaluateFunction(for: $0) > evaluateFunction(for: $1)
                        }
                        
                        ForEach(sortedSongs, id: \.id) { song in
                            SongHistoryRowView(
                                songID: song.id,
                                currentArtistName: $currentArtistName,
                                musicDefaultBpm: $musicDefaultBpm,
                                bpmErrorMessage: $bpmErrorMessage,
                                autoPause: $autoPause
                            )
                                .environmentObject(songHistoryManager)
                                .environmentObject(spmManager)
                                .environmentObject(authManager)
                        }
                        .onDelete(perform: songHistoryManager.deleteSong) // üî• „Çπ„ÉØ„Ç§„ÉóÂâäÈô§„ÇíÊúâÂäπÂåñ
                    }
                    
                    Section(footer: SpacerView()) {}
                }
                .listStyle(PlainListStyle())
            }
        }
        .task {
            for await subscription in MusicSubscription.subscriptionUpdates {
                self.musicSubscription = subscription
            }
        }
        .task {
            await loadArtistsFromTop100()
        }
    }

    // üéØ Ê§úÁ¥¢Âá¶ÁêÜ„Çí„É°„ÇΩ„ÉÉ„ÉâÂåñÔºàEnter„Ç≠„Éº & „Éú„Çø„É≥ ‰∏°Êñπ„Åß‰ΩøÁî®Ôºâ
    private func performSearch() {
        Task {
            do {
                isPerformingSearch = true
                
                var request = MusicCatalogSearchRequest(term: searchTerm, types: [Song.self, Artist.self])
                request.limit = 25
                let response = try await request.response()
                self.searchResultSongs = response.songs
                self.searchResultArtists = response.artists

                isPerformingSearch = false
            } catch {
                print("Error: \(error.localizedDescription)")
                isPerformingSearch = false
            }
        }
    }
    
    func fetchTop100JapanPlaylist() async -> Playlist? {
        do {
            // Top 100: Japan „ÅÆË≠òÂà•Â≠êÔºàÂõ∫ÂÆöÂÄ§Ôºâ
            let playlistID = MusicItemID("pl.043a2c9876114d95a4659988497567be") // ÂÖ¨ÂºèTop 100: Japan
            
            let request = MusicCatalogResourceRequest<Playlist>(matching: \.id, equalTo: playlistID)
            let response = try await request.response()
            print(response)
            return response.items.first
        } catch {
            print("üö® „Éó„É¨„Ç§„É™„Çπ„ÉàÂèñÂæóÂ§±Êïó: \(error)")
            return nil
        }
    }

    func loadArtistsFromTop100() async {
        print("üü° Top100„Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàË™≠„ÅøËæº„ÅøÈñãÂßã")

        // „Ç≠„É£„ÉÉ„Ç∑„É•„Åå„ÅÇ„Çå„Å∞„Åù„Çå„Çí‰Ωø„ÅÜ
        if let cachedArtists = loadArtistsFromDisk() {
            print("üì¶ „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„Çâ„Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàË™≠„ÅøËæº„Åø")
            await MainActor.run {
                uniqueArtists = MusicItemCollection(cachedArtists)
            }
            return
        }

        // „Å™„Åë„Çå„Å∞API„Åã„ÇâÂèñÂæó
        guard let playlist = await fetchTop100JapanPlaylist() else { return }

        do {
            let songs = try await playlist.with(.tracks).tracks ?? []
            var artistSet = Set<MusicItemID>()
            var artists: [Artist] = []

            for song in songs {
                let artistName = song.artistName
                let searchRequest = MusicCatalogSearchRequest(term: artistName, types: [Artist.self])
                let response = try await searchRequest.response()
                if let artist = response.artists.first(where: { $0.name == artistName }),
                   !artistSet.contains(artist.id) {
                    artistSet.insert(artist.id)
                    artists.append(artist)
                }
                try? await Task.sleep(nanoseconds: 150_000_000)
            }

            // „Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠ò
            saveArtistsToDisk(artists)

            await MainActor.run {
                uniqueArtists = MusicItemCollection(artists)
            }
        } catch {
            print("üö® „Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÂèñÂæó„Ç®„É©„Éº: \(error)")
        }
    }

    
    private func evaluateFunction(for song: FetchedSong) -> Double {
        guard let bpm = song.bpm else { return 0 }
        let spm = spmManager.spm
        let ratio = spm / bpm
        return asymmetricGaussian(ratio)
    }
    
    // üéµ SPM / BPM „ÇíË®àÁÆó„Åó„ÄÅÈùûÂØæÁß∞Èñ¢Êï∞„Å´ÈÅ©Áî®
    private func evaluateFunction(for song: PlayedSong) -> Double {
        let bpm = song.bpm
        let spm = spmManager.spm
        let ratio = spm / bpm

        return asymmetricGaussian(ratio)
    }

    // üéº ÈùûÂØæÁß∞Èñ¢Êï∞ÔºàÂè≥Á∑©„ÇÑ„Åã„ÉªÂ∑¶ÊÄ•ÊøÄÔºâ
    private func asymmetricGaussian(_ x: Double) -> Double {
        let x0 = 1.0
        let sigmaLeft = 0.04246609001440099
        let sigmaRight = 0.21233045007200477
        let sigma = x < x0 ? sigmaLeft : sigmaRight
        return exp(-((x - x0) * (x - x0)) / (2 * sigma * sigma))
    }
    
    private func saveArtistsToDisk(_ artists: [Artist]) {
        do {
            let encoder = JSONEncoder()
            let data = try encoder.encode(artists)
            let url = getArtistsCacheURL()
            try data.write(to: url)
            print("‚úÖ „Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠òÊ∏à„Åø")
        } catch {
            print("üö® „Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠ò„Ç®„É©„Éº: \(error)")
        }
    }
    
    private func loadArtistsFromDisk() -> [Artist]? {
        do {
            let url = getArtistsCacheURL()
            let data = try Data(contentsOf: url)
            let decoder = JSONDecoder()
            let artists = try decoder.decode([Artist].self, from: data)
            return artists
        } catch {
            print("üö® „Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„Ç≠„É£„ÉÉ„Ç∑„É•Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: \(error)")
            return nil
        }
    }
    
    func getArtistsCacheURL() -> URL {
        let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        return documents.appendingPathComponent("top100_artists.json")
    }

}

struct ArtistTopSongsView: View {
                                
    let artist: Artist
     
    @Binding var currentArtistName: String?
    @Binding var musicDefaultBpm: Double
    @Binding var bpmErrorMessage: String
    @Binding var tempoRatioEvaluationEnabled: Bool
    @Binding var autoPause: Bool
    
    @EnvironmentObject var spmManager: SPMManager
    @EnvironmentObject var songHistoryManager: SongHistoryManager
    @EnvironmentObject var authManager: AuthManager

    @State private var fetchedSongs: [FetchedSong] = []
    @State private var isLoading: Bool = true

    var body: some View {
        VStack {
            if isLoading {
                ProgressView("Loading top songs...")
                    .padding()
            } else {
                List {
                    Section(header: tempoRatioEvaluationEnabled ? Text("„Åä„Åô„Åô„ÇÅÈ†Ü") : Text("„Åä„Åô„Åô„ÇÅÈ†Ü")) {
                        let displaySongs: [FetchedSong] = {
                            if tempoRatioEvaluationEnabled {
                                return fetchedSongs.sorted {
                                    evaluateFunction(for: $0) > evaluateFunction(for: $1)
                                }
                            } else {
                                return fetchedSongs // ‰∏¶„Å≥Êõø„Åà„Åó„Å™„ÅÑ
                            }
                        }()

                        ForEach(displaySongs) { item in
                            SongInfoView(
                                songItem: item.song,
                                currentArtistName: $currentArtistName,
                                musicDefaultBpm: $musicDefaultBpm,
                                bpmErrorMessage: $bpmErrorMessage,
                                autoPause: $autoPause
                            )
                            .environmentObject(songHistoryManager)
                            .environmentObject(spmManager)
                            .environmentObject(authManager)
                            .opacity(
                                tempoRatioEvaluationEnabled
                                ? ( evaluateFunction(for: item) >= 0.5 ? evaluateFunction(for: item) : 0) // „Çπ„Ç≥„Ç¢„Å´Âøú„Åò„Å¶‰∏çÈÄèÊòéÂ∫¶„ÇíË™øÊï¥
                                : 1.0 // ‰∏¶„Å≥Êõø„Åà„Çπ„Ç≠„ÉÉ„ÉóÊôÇ„ÅØ„Åô„Åπ„Å¶‰∏çÈÄèÊòé
                            )
                        }
                    }
                    Section(footer: SpacerView()) {
                        EmptyView() // „Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ‰∏≠Ë∫´„Åå„Å™„ÅÑ„Åì„Å®„ÇíÊòéÁ§∫
                    }
                }
                .listStyle(PlainListStyle())
            }
        }
        .navigationTitle(artist.name)
        .task {
            await loadTopSongs()
        }

    }

    func loadTopSongs() async {
        self.isLoading = true
        self.fetchedSongs = []
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Åå„ÅÇ„Çå„Å∞‰Ωø„ÅÜ
        if tempoRatioEvaluationEnabled, let cached = loadTopSongsFromDisk(artistID: artist.id) {
            var tempFetchedSongs: [FetchedSong] = []
            let group = DispatchGroup()

            for cachedSong in cached {
                group.enter()
                let bpmFetcher = BPMFetcher(historyManager: songHistoryManager)
                bpmFetcher.fetchBPM(song: cachedSong.song.title, artist: cachedSong.song.artistName, id: cachedSong.song.id.rawValue) { bpm in
                    tempFetchedSongs.append(FetchedSong(song: cachedSong.song, bpm: bpm))
                    group.leave()
                }
            }

            group.notify(queue: .main) {
                self.fetchedSongs = tempFetchedSongs
                self.isLoading = false
                print("üì¶ Top songs (with BPM) loaded from cache for \(artist.name)")
            }

            return
        }

        do {
            var request = MusicCatalogSearchRequest(term: artist.name, types: [Song.self])
            request.limit = 25
            let response = try await request.response()
            let songs = response.songs.filter { $0.artistName == artist.name }.prefix(25)

            var tempFetchedSongs: [FetchedSong] = []
            let group = DispatchGroup()

            for song in songs {
                group.enter()
                let bpmFetcher = BPMFetcher(historyManager: songHistoryManager)
                bpmFetcher.fetchBPM(song: song.title, artist: song.artistName, id: song.id.rawValue) { bpm in
                    tempFetchedSongs.append(FetchedSong(song: song, bpm: bpm))
                    group.leave()
                }
            }

            group.notify(queue: .main) {
                self.fetchedSongs = tempFetchedSongs
                self.isLoading = false
                removeTopSongsCache(artistID: artist.id)
                saveTopSongsToDisk(artistID: artist.id, songs: self.fetchedSongs)
            }
        } catch {
            print("üö® Failed to fetch top songs: \(error.localizedDescription)")
            self.isLoading = false
        }
    }


    private func evaluateFunction(for song: FetchedSong) -> Double {
        guard let bpm = song.bpm else { return 0 }
        let spm = spmManager.spm
        let ratio = spm / bpm
        return asymmetricGaussian(ratio)
    }

    private func asymmetricGaussian(_ x: Double) -> Double {
        let x0 = 1.0
        let sigmaLeft = 0.04246609001440099
        let sigmaRight = 0.21233045007200477
        let sigma = x < x0 ? sigmaLeft : sigmaRight
        return exp(-((x - x0) * (x - x0)) / (2 * sigma * sigma))
    }
    
    func removeTopSongsCache(artistID: MusicItemID) {
        let filename = "top_songs_\(artistID.rawValue).json"
        let url = getCacheDirectory().appendingPathComponent(filename)
        do {
            if FileManager.default.fileExists(atPath: url.path) {
                try FileManager.default.removeItem(at: url)
                print("üóëÔ∏è Êó¢Â≠ò„Ç≠„É£„ÉÉ„Ç∑„É•ÂâäÈô§Ê∏à„Åø for \(artistID)")
            }
        } catch {
            print("‚ö†Ô∏è „Ç≠„É£„ÉÉ„Ç∑„É•ÂâäÈô§Â§±Êïó: \(error)")
        }
    }
    
    func saveTopSongsToDisk(artistID: MusicItemID, songs: [FetchedSong]) {
        let filename = "top_songs_\(artistID.rawValue).json"
        let url = getCacheDirectory().appendingPathComponent(filename)
        do {
            let data = try JSONEncoder().encode(songs)
            try data.write(to: url)
            print("‚úÖ Top songs cached for \(artistID)")
        } catch {
            print("üö® Failed to cache top songs: \(error)")
        }
    }

    func loadTopSongsFromDisk(artistID: MusicItemID) -> [FetchedSong]? {
        let filename = "top_songs_\(artistID.rawValue).json"
        let url = getCacheDirectory().appendingPathComponent(filename)
        do {
            let data = try Data(contentsOf: url)
            let songs = try JSONDecoder().decode([FetchedSong].self, from: data)
            return songs
        } catch {
            print("üö® Failed to load cached top songs: \(error)")
            return nil
        }
    }

    func getCacheDirectory() -> URL {
        FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask)[0]
    }

}

struct FetchedSong: Identifiable, Codable {
    let song: Song
    let bpm: Double?

    var id: MusicItemID { song.id }

    enum CodingKeys: CodingKey {
        case song, bpm
    }

    init(song: Song, bpm: Double?) {
        self.song = song
        self.bpm = bpm
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.song = try container.decode(Song.self, forKey: .song)
        self.bpm = try container.decodeIfPresent(Double.self, forKey: .bpm)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(song, forKey: .song)
        try container.encodeIfPresent(bpm, forKey: .bpm)
    }
}


struct SpacerView: View {
    var body: some View {
        Color.clear
            .frame(height: 200) // üéØ `MusicPlayerView` „ÅÆÈ´ò„Åï„Å´Âêà„Çè„Åõ„Å¶‰ΩôÁôΩ„ÇíÁ¢∫‰øù
    }
}
